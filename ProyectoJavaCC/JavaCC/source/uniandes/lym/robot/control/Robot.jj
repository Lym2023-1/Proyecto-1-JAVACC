/*
Gramatica para el Robot:
Autores: Daniel Diaz y Nicolas Murillo


**/


options 
{

	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;

}


PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.HashSet;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;


	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	" "
	|	"\r"
	|	"\t"
	| "\n"
}

TOKEN: /* Nombres de Comandos */
{

			<MOV:  "Mov">
		| 	<RIGHT: "RIGHT">
		| 	<PUT: "Put">
		| 	<PICK: "Pick">
		|  < POP: "Pop" >
		|  <GO: "GO" >
        |  < HOP:  "HOP" >		

}

TOKEN:
{
		<BALLOONS:  "BALLOONS" >
		|	<CHIPS:     "CHIPS"  >	

}



TOKEN :
{
		<NUM: (<DIGIT>)+ >
		|  	<#DIGIT: ["0"-"9"] >

}

TOKEN:  /* Palabras reservadas*/
{
  		<ROBOT_R:  "robot_r" >
	  	| <THEN:   "then:">
	  	| <ELSE:   "else:">
	  	| <DO:     "do:">
 		| <VARS:   "vars" >
 		| <PROCS:  "procs" >
		| <WHILE:  "while:" >
		| <IF:     "if:"  >
		| <REPEAT: "repeat:"  >
}

TOKEN :
{
 	 <NAME : (< LETTER >)(< DIGIT >|< LETTER >)* >
	| < #LETTER   : ["a"-"z","A"-"Z"] >
}



TOKEN:
{
	<ORIENTATION: "north"| "south" | "east" | "west"  >
	| <VIEW:  "front" |"right"| "left" |"back" >
	| <TURN: "left"|"right"|"around" >
}


TOKEN_MGR_DECLS : {
    HashMap<String, Integer> procedimientos = new HashMap<String, Integer>();
    HashMap<String,Number> variables = new HashMap<String,Number>();
    HashSet<String> variables_temporales= new HashSet<String>();
    HashSet<String> condiciones= new HashSet<String>();
}

	//boolean command(uniandes.lym.robot.view.Console sistema) :
	boolean command(Console sistema):
	{	

		int x,y;
		salida=new String();	
	}


	{
		(		  (
		   <RIGHT> "(" ")" {world.turnRight();salida = "Command: Turnright";}
		| 	<MOV>  "(" x=num() ")" {world.moveForward(x,false);salida = "Command: Moveforward ";}  
		| 	<HOP>  "(" x=num() ")" {world.moveForward(x,true);salida = "Command:Jumpforward ";}
		| 	<GO>  "(" x=num() "," y=num()")" {world.setPostion(x,y);salida = "Command:GO ";}  
		|  <PUT> "("  put() ")"					  			
		|  <PICK> "(" get()  ")"	
	    |  < POP > "(" x=num() ")" {world.popBalloons(x); salida = "Comando:  Pop";}
		) ";" 

		{
		    try {
	    			 Thread.sleep(900);
	    	    } catch (InterruptedException e) {
	    			        System.err.format("IOException: %s%n", e);
	    		    }

			sistema.printOutput(salida);
			return true;
		})+

    	| <EOF> {return false;} 
	}

	void put() :
	{
		int f=1;	
	}
	{
		( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
		|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 

	}

	void get() :
	{
		int f=1;	
	}
	{
		( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
		|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 

	}




void main():
	{}
	{
		<ROBOT_R> (vars())? (procs())?  block()
	}

void vars():
	{String var1,var2;}
	{
		<VARS> var1=<NAME>.image {token_source.variables.put(var1,Double.POSITIVE_INFINITY);}
		("," var2=<NAME>.image {token_source.variables.put(var2,Double.POSITIVE_INFINITY);})* ";"
	}

void procs():
	{}
	{
	<PROCS> (procDefinition())+
	}


	
void procDefinition():
	{String procName; int params; }
	{
		procName=<NAME>.image "[" "|" params=parameters() "|" multipleExecution() {token_source.variables_temporales=new HashSet<String>(); } "]"
		{saveProcInfo(procName,params);}
	 }

int parameters():
	{String parameter1, parameter2; }
	{
		(parameter1= < NAME >.image {token_source.variables_temporales.add(parameter1);} ("," parameter2=<NAME>.image  {token_source.variables_temporales.add(parameter2);})*)? 
		{return token_source.variables_temporales.size();} 	
	}

void saveProcInfo(String procName, int params):
	{}
	//Se guarda el nombre del procedimiento y se revisa que no sea variable ni condicion
	{
		{
			if (token_source.variables.containsKey(procName))throw new Error("El procedimiento ya se declaró como variable");
			else if (token_source.condiciones.contains(procName))throw new Error("El procedimiento es una condición");
			else token_source.procedimientos.put(procName,params);
		}
	}


void block():
	{}
	{
	("[" multipleExecution() "]") | (singleExecution())
	}


	
void multipleExecution():
	{}
	{
	singleExecution() ( ";"  singleExecution())* 
	}


void singleExecution():
	{}
	{
	declaredProcedureCall()|controlStructure()|procedureCall()
	}
void procedureCall():
	{String procName;int cantidad;}
	{
	procName=< NAME >.image ":" cantidad=declaredParameters() {if (token_source.procedimientos.containsKey(procName)==false)throw new Error("El procedimiento no esta definido");
														else if (token_source.procedimientos.get(procName)!=cantidad) throw new Error("Faltan parametros");}
	}
	
void controlStructure():
	{}
	{
		(IF()) | (WHILE()) | (REPEAT())
	}



int declaredParameters():
	{int cantidad=0; String parameter1,parameter2;}
	//Se revisa que los parametros esten definidos
	{
		(parameter1= < NAME >.image {checkParameters(parameter1); cantidad++ ;} ("," parameter2=< NAME >.image{checkParameters(parameter2); cantidad++; }  )*)?
		{return cantidad;}
	}
	


void checkParameters(String parameter):
{}

{
		{
			if (token_source.variables.containsKey(parameter)==false &&
				token_source.variables_temporales.contains(parameter)==false)throw new Error(parameter +" no esta definido");

		}
}


void IF():
	{}
	{
	<IF>  conditionalCall() <THEN>   block() <ELSE>  block()
	}

void WHILE():
	{}
	{
	<WHILE>  conditionalCall() <DO>  block()
	}


void REPEAT():
	{int num;}
	{
	<REPEAT>  (num=num()|(num=getVarNum())) block()
	} 



void declaredProcedureCall():
	{int n,Cx,Cy; String d,x,name,o;}
	{
	"assignto:"  n=num() "," name=<NAME>.image {if (token_source.variables.containsKey(name)==false)throw new Error(name +" no esta definido");token_source.variables.put(name,n);}
	| "goto:"   (Cx=num()|(Cx=getVarNum())) "," (Cy=num()|(Cy=getVarNum()))
	| "move:"   (n=num()|(n=getVarNum()))
	| "turn:"   (d=<TURN>.image)
	| "face:"  (o=<ORIENTATION>.image)
	| "put:"  (n=num()|(n=getVarNum())) "," (x=<BALLOONS>.image|x=<CHIPS>.image)
	| "pick:" (x=<BALLOONS>.image|x=<CHIPS>.image)"," (n=num()|(n=getVarNum()))
	| "movetothe:"  (n=num()|(n=getVarNum())) "," (d=<VIEW>.image)
	| "moveindir:"  (n=num()|(n=getVarNum())) "," (d=<ORIENTATION>.image)
	| "jumptothe:"  (n=num()|(n=getVarNum())) "," (d=<ORIENTATION>.image)
	| "jumpindir:"  (n=num()|(n=getVarNum())) "," (d=<ORIENTATION>.image)
	}

void conditionalCall():	
	{int n; String x,d,o;}
	{
	"facing:"   o=<ORIENTATION>.image
	|"canPut:"  (n=num()|(n=getVarNum())) ","  (x=<BALLOONS>.image|x=<CHIPS>.image) 
	|"canPick:"    (n=num()|(n=getVarNum()))","(x=<BALLOONS>.image|x=<CHIPS>.image)
	|"canMoveInDir:"  (n=num()|(n=getVarNum()))"," d=<ORIENTATION>.image
	|"canJumpInDir:"  (n=num()|(n=getVarNum()))"," d=<ORIENTATION>.image
	|"canMoveToThe:"  (n=num()|(n=getVarNum()))"," o=<VIEW>.image
	|"canJumpToThe:"  (n=num()|(n=getVarNum()))"," o=<VIEW>.image
	|"not:" conditionalCall()
	} 





	int num() throws Error:
	{	
		int total=1;
	}
	{
		<NUM>
		{
			try 
			{
				total = Integer.parseInt(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image+" !!");
			}
			return total;
		}
	}



	int getVarNum() throws Error:
	{
		Token token;
		Number number;
	}
	
	{
		(token= <NAME>)
	
			{
			  	
				if (token_source.variables.containsKey(token.image)==false) throw new Error(token.image + " no esta definido");

				number=token_source.variables.get(token.image);
				if (number.equals(Double.POSITIVE_INFINITY)) throw new Error("La variable posee el valor indefinido");
				
				return (int)number;
			}
	}
